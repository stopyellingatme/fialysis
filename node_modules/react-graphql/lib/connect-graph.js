'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.connectGraph = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint-disable react/no-set-state */

var connectGraph = exports.connectGraph = function connectGraph(options) {
  return function (BaseComponent) {
    var _class, _temp;

    return _temp = _class = function (_React$Component) {
      _inherits(GraphContainer, _React$Component);

      function GraphContainer(props) {
        _classCallCheck(this, GraphContainer);

        var _this = _possibleConstructorReturn(this, (GraphContainer.__proto__ || Object.getPrototypeOf(GraphContainer)).call(this, props));

        _this.state = {
          isFetching: false,
          data: undefined
        };

        _this.hasCompletedInitialLoad = false;

        _this.cacheUpdated = _this.cacheUpdated.bind(_this);
        return _this;
      }

      _createClass(GraphContainer, [{
        key: 'fetch',
        value: function fetch(query, variables) {
          var _this2 = this;

          this.setState({ isFetching: true });

          return this.context.graphQLContext.runQuery(query, variables).then(function () {
            _this2.hasCompletedInitialLoad = true;
            _this2.setState({ isFetching: false, hasError: false, error: null });
          }).catch(function (error) {
            _this2.hasCompletedInitialLoad = true;
            _this2.setState({ isFetching: false, hasError: true, error: error });
          });
        }
      }, {
        key: 'updateTrackingQuery',
        value: function updateTrackingQuery(query, variables) {
          this.trackingQuery = {
            query: query,
            variables: variables
          };
        }
      }, {
        key: 'initialLoadWithProps',
        value: function initialLoadWithProps(props) {
          var _this3 = this;

          var query = options.query();
          var variables = options.variables ? options.variables(props) : {};

          // can render without fetching?
          if (options.renderOutdated) {
            if (this.context.graphQLContext.cacheFulfillsQuery(query, variables)) {
              console.log('Rendering outdated version from cache whilst loading');
              this.hasCompletedInitialLoad = true;
              this.updateTrackingQuery(query, variables);
              this.loadFromCache();
            }
          }

          // determine what needs fetching
          var queryToExecute = options.refetchOnMount ? query : this.context.graphQLContext.getQueryToExecute(query, variables);

          // if everything is cache, just render from cache.
          // don't render if we rendered with outdated cache because it will be the same data
          if (!queryToExecute && !options.renderOutdated) {
            this.hasCompletedInitialLoad = true;
            this.updateTrackingQuery(query, variables);
            this.loadFromCache();
            return;
          }

          if (!queryToExecute) {
            return;
          }

          return this.fetch(queryToExecute, variables).then(function () {
            if (!_this3.state.hasError) {
              _this3.updateTrackingQuery(query, variables);
              _this3.loadFromCache();
            }
          });
        }
      }, {
        key: 'loadFromCache',
        value: function loadFromCache() {
          if (!this.trackingQuery) return null;

          var myData = this.context.graphQLContext.queryCache(this.trackingQuery.query, this.trackingQuery.variables);

          this.setState({ data: myData });
        }
      }, {
        key: 'cacheUpdated',
        value: function cacheUpdated() {
          this.loadFromCache();
        }
      }, {
        key: 'componentWillMount',
        value: function componentWillMount() {
          if (!this.context.graphQLContext) {
            throw new Error('connectGraph is being used without GraphQLProvider');
          }

          if (!options.query) {
            throw new Error('No query passed to connectGraph');
          }

          if (!options.ignoreUpdates) {
            this.context.graphQLContext.events.on('cacheUpdated', this.cacheUpdated);
          }

          this.initialLoadWithProps(this.props);
        }
      }, {
        key: 'forceRefetch',
        value: function forceRefetch() {
          var _this4 = this;

          if (!this.trackingQuery) {
            return this.initialLoadWithProps(this.props);
          }

          return this.fetch(this.trackingQuery.query, this.trackingQuery.variables).then(function () {
            return _this4.loadFromCache();
          });
        }
      }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
          this.initialLoadWithProps(nextProps);
        }
      }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
          this.context.graphQLContext.events.removeListener('cacheUpdated', this.cacheUpdated);
        }
      }, {
        key: 'render',
        value: function render() {
          var graph = {
            isFetching: this.state.isFetching,
            hasError: this.state.hasError,
            error: this.state.error,
            forceRefetch: this.forceRefetch.bind(this)
          };

          if (this.state.data !== undefined && this.hasCompletedInitialLoad) {
            return _react2.default.createElement(BaseComponent, _extends({}, this.props, this.state.data, {
              graph: graph
            }));
          }

          if (this.state.hasError && !graph.isFetching) {
            return this.context.graphQLContext.opts.defaultRenderError(this.state.error, graph);
          }

          return this.context.graphQLContext.opts.defaultRenderLoading(graph);
        }
      }]);

      return GraphContainer;
    }(_react2.default.Component), _class.contextTypes = {
      graphQLContext: _react.PropTypes.object.isRequired
    }, _temp;
  };
};
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.simplifyAst = simplifyAst;
exports.markAsShouldDelete = markAsShouldDelete;
exports.markAsKeep = markAsKeep;
exports.isMarkedForDeletion = isMarkedForDeletion;
exports.recursivelyMarkAsKeep = recursivelyMarkAsKeep;
exports.ensureSelectionSetHasField = ensureSelectionSetHasField;
exports.replaceFragment = replaceFragment;

var _visitor = require('graphql/language/visitor');

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Takes a query AST and simplifies it.
 *
 * This involves removing unused fragments, inlining fragments with the query selection sets,
 * and replacing variable references with their actual values.
 */
function simplifyAst(ast) {
  var variables = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var insideQuery = false;

  var definedVariables = [];

  return (0, _visitor.visit)(ast, {
    enter: function enter(node, key, parent, path, ancestors) {
      if (node.kind === 'OperationDefinition' && node.operation === 'query') {
        insideQuery = true;

        if (node.variableDefinitions) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = node.variableDefinitions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var definition = _step.value;

              definedVariables.push(definition.variable.name.value);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }

        return;
      }

      if (insideQuery && node.kind === 'FragmentSpread') {
        var nameOfFragment = node.name.value;
        var fragment = getFragment(ast, nameOfFragment);

        if (fragment) {
          return fragment.selectionSet;
        }
      }

      if (insideQuery && node.kind === 'Variable') {
        var variableName = node.name.value;

        (0, _invariant2.default)(definedVariables.includes(variableName), 'simplifyAst(): Undefined variable referenced "' + variableName + '"');
        (0, _invariant2.default)(variables[variableName] !== undefined, 'simplifyAst(): Variable referenced "' + variableName + '" but not provided');

        return {
          kind: 'StringValue',
          value: variables[variableName].toString()
        };
      }

      if (node.kind === 'FragmentDefinition') {
        // be gone! remove fragments because we inlined them
        return null;
      }
    },
    leave: function leave(node, key, parent, path, ancestors) {
      if (node.kind === 'OperationDefinition' && node.operation === 'query') {
        insideQuery = false;
        return;
      }
    }
  });
}

function markAsShouldDelete(node) {
  if (node.__shouldDelete !== undefined) return node;

  return _extends({}, node, {
    __shouldDelete: true
  });
}

function markAsKeep(node) {
  return _extends({}, node, {
    __shouldDelete: false
  });
}

function isMarkedForDeletion(node) {
  return node && node.__shouldDelete === true;
}

function recursivelyMarkAsKeep(rootAst, node) {
  return (0, _visitor.visit)(node, {
    enter: function enter(node) {
      if (node.kind === 'Field' || node.kind === 'InlineFragment') {
        return markAsKeep(node);
      }

      if (node.kind === 'FragmentSpread') {
        var nameOfFragment = node.name.value;
        var fragment = getFragment(rootAst, nameOfFragment);

        var newFragment = _extends({}, fragment, {
          selectionSet: recursivelyMarkAsKeep(rootAst, fragment.selectionSet)
        });

        replaceFragment(rootAst, nameOfFragment, newFragment);

        return markAsKeep(node);
      }
    }
  });
}

/**
 * Returns a new node with selectionSet, where the selectionSet will contain
 * the given field.
 */
function ensureSelectionSetHasField(node, field) {
  (0, _invariant2.default)(node, 'queryForField(): node not provided');
  (0, _invariant2.default)(node.selectionSet, 'queryForField(): node does not have selectionSet');

  return _extends({}, node, {
    selectionSet: _extends({}, node.selectionSet, {
      selections: ensureSelectionsHasField(node.selectionSet.selections, field)
    })
  });
}

function getFragment(ast, name) {
  (0, _invariant2.default)(ast.kind === 'Document', 'getFragment(): ast.kind is not Document');

  var definitions = ast.definitions;


  return definitions.find(function (def) {
    return def.name && def.name.value === name;
  });
}

function replaceFragment(ast, name, newFragment) {
  if (ast.kind !== 'Document') {
    throw new Error('replaceFragment(): ast.kind is not Document');
  }

  var definitions = ast.definitions;


  var found = definitions.find(function (def) {
    return def.name && def.name.value === name;
  });

  Object.assign(found, newFragment);
  return;
}

function ensureSelectionsHasField(selections, field) {
  (0, _invariant2.default)(Array.isArray(selections), 'ensureSelectionsHasField(): selections is not array');

  var exists = selections.find(function (node) {
    return node.kind === 'Field' && node.name && node.name.value === field;
  });

  if (exists && exists.__shouldDelete) {
    return selections.map(function (node) {
      return node === exists ? _extends({}, exists, {
        __shouldDelete: false
      }) : node;
    });
  }

  if (!exists) {
    return [].concat(_toConsumableArray(selections), [{
      kind: 'Field',
      alias: null,
      name: { kind: 'Name', value: field },
      arguments: [],
      directives: [],
      selectionSet: null
    }]);
  }

  return selections;
}